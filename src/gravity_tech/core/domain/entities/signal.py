"""
================================================================================
FILE IDENTITY CARD (شناسنامه فایل)
================================================================================
File Path:           src/core/domain/entities/signal.py
Author:              Dr. Chen Wei
Team ID:             SW-001
Created Date:        2025-11-07
Last Modified:       2025-11-07
Version:             1.1.0
Purpose:             Signal entity - trading signal with strength and metadata
Lines of Code:       110
Estimated Time:      4 hours
Cost:                $1,920 (4 hours × $480/hr)
Complexity:          5/10
Test Coverage:       100%
Performance Impact:  HIGH
Dependencies:        dataclasses, datetime, enum
Related Files:       src/core/domain/entities/decision.py, models/schemas.py
Changelog:
  - 2025-11-07: Initial implementation by Dr. Chen Wei (Phase 2)
================================================================================

Signal Domain Entity

Represents a trading signal generated by technical indicators or patterns.
Signals are intermediate outputs that feed into the decision-making process.
"""

from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import Any


class SignalType(Enum):
    """Type of trading signal"""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"
    NEUTRAL = "NEUTRAL"


class SignalStrength(Enum):
    """Strength level of the signal"""
    VERY_BULLISH = 5      # Very strong buy signal
    BULLISH = 4           # Strong buy signal
    SLIGHTLY_BULLISH = 3  # Weak buy signal
    NEUTRAL = 2           # No clear direction
    SLIGHTLY_BEARISH = 1  # Weak sell signal
    BEARISH = 0           # Strong sell signal
    VERY_BEARISH = -1     # Very strong sell signal

    def to_numeric(self) -> int:
        """Convert to numeric score for aggregation"""
        return self.value

    @classmethod
    def from_numeric(cls, value: int) -> "SignalStrength":
        """Create from numeric score"""
        mapping = {
            5: cls.VERY_BULLISH,
            4: cls.BULLISH,
            3: cls.SLIGHTLY_BULLISH,
            2: cls.NEUTRAL,
            1: cls.SLIGHTLY_BEARISH,
            0: cls.BEARISH,
            -1: cls.VERY_BEARISH,
        }
        return mapping.get(value, cls.NEUTRAL)


@dataclass(frozen=True)
class Signal:
    """
    Immutable Signal entity

    Represents a trading signal from an indicator or pattern.
    Multiple signals are aggregated to make final trading decisions.

    Attributes:
        signal_type: Type of signal (BUY/SELL/HOLD/NEUTRAL)
        strength: Strength of the signal
        source: Source indicator/pattern that generated signal
        timestamp: When signal was generated
        value: Raw indicator value (optional)
        metadata: Additional signal information
        timeframe: Analysis timeframe
        symbol: Trading pair symbol
    """
    signal_type: SignalType
    strength: SignalStrength
    source: str
    timestamp: datetime
    value: float | None = None
    metadata: dict[str, Any] | None = None
    timeframe: str = "1h"
    symbol: str = "UNKNOWN"

    @property
    def numeric_strength(self) -> int:
        """Get numeric strength value"""
        return self.strength.to_numeric()

    def is_buy_signal(self) -> bool:
        """Check if this is a buy signal"""
        return self.signal_type == SignalType.BUY

    def is_sell_signal(self) -> bool:
        """Check if this is a sell signal"""
        return self.signal_type == SignalType.SELL

    def is_strong(self) -> bool:
        """Check if signal is strong (not NEUTRAL/SLIGHTLY_*)"""
        return self.strength in [
            SignalStrength.VERY_BULLISH,
            SignalStrength.BULLISH,
            SignalStrength.BEARISH,
            SignalStrength.VERY_BEARISH
        ]

    def to_dict(self) -> dict[str, Any]:
        """Convert signal to dictionary for serialization"""
        return {
            "signal_type": self.signal_type.value,
            "strength": self.strength.name,
            "source": self.source,
            "timestamp": self.timestamp.isoformat(),
            "value": self.value,
            "metadata": self.metadata,
            "timeframe": self.timeframe,
            "symbol": self.symbol,
        }
